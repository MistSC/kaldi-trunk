<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: Parallelization in Kaldi</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('queue.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Parallelization in Kaldi </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="parallelization_intro"></a>
Introduction</h1>
<p>Kaldi is designed to work best with software such as Sun GridEngine or other software that works on a similar principle; and if multiple machines are to work together in a cluster then they need access to a shared file system such as one based on NFS. However, Kaldi can easily be configured to run on a single machine.</p>
<p>If you look at a top-level example script like <code>egs/wsj/s5/run.sh</code>, you'll see commands like </p>
<pre class="fragment"> steps/train_sat.sh  --cmd "$train_cmd" \
   4200 40000 data/train_si284 data/lang exp/tri3b_ali_si284 exp/tri4a
</pre><p> At the top of the <code>run.sh</code> script you'll see it sourcing a file called <code>cmd.sh</code>: </p>
<pre class="fragment">. ./cmd.sh
</pre><p> and in <code>cmd.sh</code> you'll see the following variable being set: </p>
<pre class="fragment">export train_cmd="queue.pl -l arch=*64"
</pre><p> You'll change this variable if you don't have GridEngine or if your queue is configured differently from CLSP@JHU. To run everything locally on a single machine you can set <code>export train_cmd=run.pl</code>.</p>
<p>In <code>steps/train_sat.sh</code> the varible <code>cmd</code> is set to the argument to the <code>&ndash;cmd</code> option, i.e. to <code>queue.pl -l arch=*64</code> in this case, and in the script you'll see commands like the following: </p>
<pre class="fragment">      $cmd JOB=1:$nj $dir/log/fmllr.$x.JOB.log \
        ali-to-post "ark:gunzip -c $dir/ali.JOB.gz|" ark:-  \| \
        weight-silence-post $silence_weight $silphonelist $dir/$x.mdl ark:- ark:- \| \
        gmm-est-fmllr --fmllr-update-type=$fmllr_update_type \
        --spk2utt=ark:$sdata/JOB/spk2utt $dir/$x.mdl \
        "$feats" ark:- ark:$dir/tmp_trans.JOB || exit 1;
</pre><p> What's going on is that the command <code>$cmd</code> (e.g. <code>queue.pl</code> or <code>run.pl</code>) is being executed; it is responsible for spawning the jobs and waiting until they are done, and returning with nonzero status if something went wrong. The basic usage of these commands (and there are others called <code>slurm.pl</code> and <code>ssh.pl</code>) is like this: </p>
<pre class="fragment"> queue.pl &lt;options&gt; &lt;log-file&gt; &lt;command&gt;
</pre><p> and the simplest possible example of using one of these scripts is: </p>
<pre class="fragment"> run.pl foo.log echo hello world
</pre><p> (we're using <code>run.pl</code> for the example because it will run on any system, it doesn't require GridEngine). It's possible to run a one-dimensional array of jobs, and an example is: </p>
<pre class="fragment"> run.pl JOB=1:10 foo.JOB.log echo hello world number JOB
</pre><p> and these programs will replace any instance of JOB in the command line with a number within that range, so make sure that your working directory doesn't contain the string JOB, or bad things may happen. You can even submit jobs with pipes and redirection by suitable use of quoting or escaping: </p>
<pre class="fragment"> run.pl JOB=1:10 foo.JOB.log echo "hello world number JOB" \| head -n 1 \&gt; output.JOB
</pre><p> In this case, the command that actually gets executed will be something like: </p>
<pre class="fragment">echo "hello world number JOB" | head -n 1 &gt; output.JOB
</pre><p> If you want to see what's actually getting executed, you can look in a file like <code>foo.1.log</code>, where you'll see the following: </p>
<pre class="fragment"># echo "hello world number 1" | head -n 1 &gt; output.1
# Started at Sat Jan  3 17:44:20 PST 2015
#
# Accounting: time=0 threads=1
# Ended (code 0) at Sat Jan  3 17:44:20 PST 2015, elapsed time 0 seconds
</pre><h1><a class="anchor" id="parallelization_common"></a>
Common interface of parallelization tools</h1>
<p>In this section we discuss the commonalities of the parallelization tools. They are designed to all be interchangeable on the command line, so that a script that is tested for one of these parallelization tools will work for any; you can switch over to using another by setting the <code>$cmd</code> variable to a different value.</p>
<p>The basic usage of these tools is, as we said, </p>
<pre class="fragment"> queue.pl &lt;options&gt; &lt;log-file&gt; &lt;command&gt;
</pre><p> and what we are about to say also holds for <code>run.pl</code>, <code>ssh.pl</code> and <code>slurm.pl</code>.</p>
<p><code>&lt;options&gt;</code> may include some or all of the following: </p>
<ul>
<li>
A job range specifier (e.g. JOB=1:10). The name is uppercase by convention only, and may include underscores. The starting index must be 1 or more; this is a GridEngine limitation. </li>
<li>
Anything that looks as if it would be accepted by GridEngine as an option to <code>qsub</code>. For example, <code>-l arch=*64*</code>, or <code>-l mem_free=6G,ram_free=6G</code>, or <code>-pe smp 6</code>. For compatibility, scripts other than <code>queue.pl</code> will ignore such options. </li>
<li>
New-style options like <code>&ndash;mem 10G</code> (see below). </li>
</ul>
<p><code>&lt;log-file&gt;</code> is just a filename, which for array jobs must contain the identifier of the array (e.g. <code>exp/foo/log/process_data.JOB.log</code>).</p>
<p><code>&lt;command&gt;</code> can basically be anything, including symbols that would be interpreted by the shell, but of course <code>queue.pl</code> can't process something if it gets interpreted by <code>bash</code> first. For instance, this is WRONG: </p>
<pre class="fragment"> queue.pl test.log  echo foo | awk 's/f/F/';
</pre><p> because <code>queue.pl</code> won't even see the arguments after the pipe symbol, but will get its standard output piped into the awk command. Instead you should write </p>
<pre class="fragment"> queue.pl test.log  echo foo \| awk 's/f/F/';
</pre><p> You need to escape or quote the pipe symbol, and also things like ";" and "&gt;". If one of the arguments in the <code>&lt;command&gt;</code> contains a space, then queue.pl will assume you quoted it for a reason, and will quote it for you when it gets passed to bash. It quotes using single quotes by default, but if the string itself contains single quotes then it uses double quotes instead. This usually does what we want. The <code>PATH</code> variable from the shell that you executed queue.pl from will be passed through to the scripts that get executed, and just to be certain you get everything you need, the file <code>./path.sh</code> will also be sourced. The commands will be executed with bash.</p>
<h2><a class="anchor" id="parallelization_common_new"></a>
New-style options (unified interface)</h2>
<p>When we originally wrote Kaldi, we made the example scripts pass in options like <code>-l ram_free=6G,mem_free=6G</code> to <code>queue.pl</code>, when we needed to specify things like memory requirements. Because the scripts like <code>steps/train_sat.sh</code> can't make assumptions about how GridEngine is configured or whether we are using GridEngine at all, such options had to be passed in from the very outer level of the scripts, which is awkward. We have more recently defined a "new-style interface" to the parallelization scripts, such that they all accept the following types of options (examples shown): </p>
<pre class="fragment">   --config conf/queue_mod.conf
   --mem 10G
   --num-threads 6
   --max-jobs-run 10
   --gpu 1
</pre><p> The config file specifies how to convert new-style options into a form that GridEngine (or your grid software of choice) can interpret. Currently only <code>queue.pl</code> actually interprets these options; the other scripts ignore them. Our plan is to gradually modify the scripts in <code>steps/</code> to make use of the new-style options, where necessary, and to use <code>queue.pl</code> for other varieties of grid software through use of the config files (where possible).</p>
<p><code>queue.pl</code> will read <code>conf/queue.conf</code> if it exists; otherwise it will default to a particular config file that we define in the code. The config file specifies how to convert the "new-style" options into options that GridEngine or similar software can interpret. The following example show the behavior that the default config file specifies: </p>
<table class="doxtable">
<tr>
<th>New-style option  </th><th>Converted form (for GridEngine)  </th><th>Comment   </th></tr>
<tr>
<td><code>&ndash;mem 10G</code> </td><td><code>-l mem_free=10G,ram_free=10G</code> </td><td></td></tr>
<tr>
<td><code>&ndash;max-jobs-run 10</code> </td><td><code>-tc 10</code> </td><td>(We use this for jobs that cause too much I/O).  </td></tr>
<tr>
<td><code>&ndash;num-threads 6</code> </td><td><code>-pe smp 6</code> </td><td>(general case)  </td></tr>
<tr>
<td><code>&ndash;num-threads 1</code> </td><td><code>(no extra options)</code> </td><td>(special case)  </td></tr>
<tr>
<td><code>&ndash;gpu 1</code> </td><td><code>-q g.q -l gpu=1 </code> </td><td>(general case)  </td></tr>
<tr>
<td><code>&ndash;gpu 0</code> </td><td>(no extra options)  </td><td>(special case for gpu=0)  </td></tr>
</table>
<p>It's also possible to add extra options with this general format, i.e. options that look like <code>&ndash;foo-bar</code> and take one argument. The default configuration tabulated above works for the CLSP grid but may not work everywhere, because GridEngine is very configurable. Thefore you may have to create a config file <code>conf/queue.conf</code> and edit it to work with your grid. The following configuration file is the one that <code>queue.pl</code> defaults to if <code>conf/queue.conf</code> does not exist and the <code>&ndash;config</code> option is not specified, and may be used as a starting point for your own config file: </p>
<pre class="fragment"># Default configuration
command qsub -v PATH -cwd -S /bin/bash -j y -l arch=*64*
option mem=* -l mem_free=$0,ram_free=$0
option mem=0          # Do not add anything to qsub_opts
option num_threads=* -pe smp $0
option num_threads=1  # Do not add anything to qsub_opts
option max_jobs_run=* -tc $0
default gpu=0
option gpu=0
option gpu=* -l gpu=$0 -q g.q
</pre><p> The line beginning with <code>command</code> specifies the unchanging part of the command line, and you can modify this to get it to use grid software other than GridEngine, or to specify options that you always want. The lines beginning with <code>option</code> specify how to transform the input options such as <code>&ndash;mem</code>. Lines beginning with something like <code>"option mem=*"</code> handle the general case (the <code>$0</code> gets replaced with the actual argument to the option), while lines like <code>"option gpu=0"</code> allow you to specify special behavior for special cases of the argument, so in this case the option <code>&ndash;gpu 0</code> is configured to produce no extra options to <code>qsub</code> at all. The line <code>"default gpu=0"</code> specifies that if you don't give the <code>&ndash;gpu</code> option at all, <code>queue.pl</code> should act like you specified <code>&ndash;gpu 0</code>. In this particular configuration we could have omitted the line <code>default gpu=0</code>, because in any case the effect is to produce no extra command line options. We previously had it configured with a line: <code>"option gpu=0 -q all.q"</code>, so there was a time when the line <code>"default gpu=0"</code> used to make a difference.</p>
<p>The mapping from what the config-file specifies to what appears on the command-line of qsub sometimes has to be tweaked slightly in the perl code: for instance, we made it so that the <code>&ndash;max-jobs-run</code> option is ignored for non-array jobs.</p>
<h2><a class="anchor" id="parallelization_common_new_example"></a>
Example of configuring grid software with new-style options</h2>
<p>We'd like to give an example of how the config file can be used in a real situation. We had a problem where, due to a bug in an outdated version of the CUDA toolkit that we had installed on the grid, some of our neural net training runs were crashing on our K20 GPU cards but not the K10s. We created a config file <code>conf/no_k20.conf</code> which was as the configuration file above (search in the text above for <code># Default configuration</code>, but with the following lines added: </p>
<pre class="fragment">default allow_k20=true
option allow_k20=true
option allow_k20=false -l 'hostname=!g01*&amp;!g02*&amp;!b06*'
</pre><p> We then set the relevant <code>$cmd</code> variable to the value <code>queue.pl -config conf/no_k20.conf &ndash;allow-k20 false</code>. Note that a simpler way to have done this would have been to simply edit the <code>command</code> line in the config file to read </p>
<pre class="fragment">command qsub -v PATH -cwd -S /bin/bash -j y -l arch=*64* -l 'hostname=!g01*&amp;!g02*&amp;!b06*'
</pre><p> and if we had done that, it would not have been necessary to add <code>&ndash;allow-k20 false</code>.</p>
<h1><a class="anchor" id="parallelization_specific"></a>
Parallelization using specific scripts</h1>
<p>In this section we explain the things that are specific to individual parallelization scripts.</p>
<h2><a class="anchor" id="parallelization_specific_queue"></a>
Parallelization using queue.pl</h2>
<p><code>queue.pl</code> is the normal, recommended way to parallelize. It was originally designed for use with GridEngine, but now that we have introduced the "new-style options" we believe it can be configured for use with other parallelization engines, such as Tork or slurm. If you develop config files that work for such engines, please contact the maintainers of Kaldi. It may also be necessary to make further changes to <code>queue.pl</code> to properly support other engines, since some parts of the command line are currently constructed in <code>queue.pl</code> in a way that is not configurable from the command line: e.g., adding <code>-o foo/bar/q/jobname.log</code> to direct output from <code>qsub</code> itself to a separate log-file; and for array jobs, adding options like <code>-t 1:40</code> to the command line. The scripts that we ask <code>qsub</code> to run also make use of the variable <code>$SGE_TASK_ID</code>, which SGE sets to the job index for array jobs. Our plan is to extend the config-file mechanism as necessary to accommodate whatever changes are needed to support other grid software, within reason.</p>
<p>Since we have explained the behavior of <code>queue.pl</code> at length above, we aren't going to provide many further details in this section, but please see below the section <a class="el" href="queue.html#parallelization_gridengine">Setting up GridEngine for use with Kaldi</a>.</p>
<h2><a class="anchor" id="parallelization_specific_run"></a>
Parallelization using run.pl</h2>
<p><code>run.pl</code> is a fall-back option in case the user does not have GridEngine installed. This script is very simple; it runs all the jobs you request on the local machine, and it does so in parallel if you use a job range specifier like <code>JOB=1:10</code>. in parallel on the local machine. It doesn't try to keep track of how many CPUs are available or how much memory your machine has. Therefore if you use <code>run.pl</code> to run scripts that were designed to run with <code>queue.pl</code> on a larger grid, you may end up exhausting the memory of your machine or overloading it with jobs. We recommend to study the script you are running, and being particularly careful with decoding scripts that run in the background (with <code>&amp;</code>) and with scripts that use a large number of jobs, e.g. <code>&ndash;nj 50</code>. Generally speaking you can reduce the value of the <code>&ndash;nj</code> option without affecting the outcome, but there are some situations where the <code>&ndash;nj</code> options given to multiple scripts must match, or a later stage will crash.</p>
<p><code>run.pl</code> will ignore all options given to it except for the job-range specifier.</p>
<h2><a class="anchor" id="parallelization_specific_ssh"></a>
Parallelization using ssh.pl</h2>
<p><code>ssh.pl</code> is a poor man's <code>queue.pl</code>, for use in case you have a small cluster of several machines but don't want the trouble of setting up GridEngine. Like <code>run.pl</code>, it doesn't attempt to keep track of CPUs or memory; it works like <code>run.pl</code> except that it distributes the jobs across multiple machines. You have to create a file <code>.queue/machines</code> (where <code>.queue</code> is a subdirectory of the directory you are running the script from), where each line contains the name of a machine. It needs to be possible to ssh to each of these machines without a password, i.e. you have to set up your ssh keys.</p>
<h2><a class="anchor" id="parallelization_specific_slurm"></a>
Parallelization using slurm.pl</h2>
<p><code>slurm.pl</code> was written to accomodate the <code>slurm</code> grid management tool, which operates on similar principles to GridEngine. It has not been tested very recently. Probably it is now possible to set up <code>queue.pl</code> to use <code>slurm</code> using a suitable configuration file, which would make <code>slurm.pl</code> unnecessary.</p>
<h1><a class="anchor" id="parallelization_gridengine"></a>
Setting up GridEngine for use with Kaldi</h1>
<p>Sun GridEngine (SGE) is the open-source grid management tool that we (the maintainers of Kaldi) have most experience with. Oracle now maintains SGE and has started calling it Oracle GridEngine. The version that is in use at CLSP@JHU is 6.2u5; SGE is old and fairly stable so the precise version number is not too critical. There are various open-source alternatives to SGE and various forks of it, but our instructions here relate to the main-line version which is currently maintained by Oracle.</p>
<p>In this section we explain how to install and configure GridEngine on an arbitrary cluster. If you have a cluster in Amazon's EC2 cloud and you want something that can take care of spinning up new nodes, you might want to look at MIT's StarCluster project, although we (the maintainers of Kaldi) have also created a project called "kluster" on Sourceforge that provides some scripts and documentation for the same purpose. StarCluster was not very stable at the time we developed kluster, but we believe it's improved since then.</p>
<h2><a class="anchor" id="parallelization_gridengine_installing"></a>
Installing GridEngine</h2>
<p>To start with, you probably want to get a basic installation of GridEngine working. In GridEngine, the queue management software runs on the "master", and a different set of programs runs on all the nodes. The master can also be a node in the queue. There's also a concept of a "shadow master" which is like a backup for the master, in case the master dies, but we won't address that here (probably it's just a question of installing the <code>gridengine-master</code> package on another node and setting the master to be another node, but we're not sure).</p>
<p>Last time we checked, installing GridEngine from source was a huge pain. Your life will be much easier if your distribution of Linux has a GridEngine package in its repositories, and choose your distribution wisely because not all distributions have such a package. We'll discuss how to do this with Debian, because that's what we're most experienced with.</p>
<p>To install GridEngine on the master, you'll run (on your chosen master node): </p>
<pre class="fragment">  sudo apt-get install gridengine-master gridengine-client
</pre><p> Select "yes" for automatic configuration. It will ask you for the "cell name", which you can leave as "default", and it will ask for the name of the "master", which you should set to the hostname of your chosen master. Typically this should be the fully qualified domain name (FQDN) of the master, but I believe anything that resolves via hostname lookup to the master node should work. Note that GridEngine is sometimes picky about about hostname lookup and reverse DNS lookup matching up, and GridEngine problems can sometimes be traced to this. Also be aware that doing "apt-get remove" of these packages and reinstalling them won't give you a blank slate because Debian sometimes remembers your selections; this can be a pain.</p>
<p>It will make your life easier if you add yourself as manager, so do: </p>
<pre class="fragment"> sudo qconf -am &lt;your-user-id&gt;
</pre><p> Here "am" means add manager; "dm" would mean delete manager and "sm" would mean show all managers. To see the available options, do <code>qconf -help</code>.</p>
<p>To install GridEngine on the normal nodes, you'll run </p>
<pre class="fragment">  sudo apt-get install gridengine-client gridengine-exec
</pre><p> The "cell name" should be left as "default", and the "master" should be the name of the master node that you previously installed. You can run this on the master too if the master is to run jobs also.</p>
<p>Typing <code>qstat</code> and <code>qhost -q</code> will let you know whether things are working. The following is what it looks like when things are working fine (we tested this in the Google cloud): </p>
<pre class="fragment">dpovey_gmail_com@instance-1:~$ qstat
dpovey_gmail_com@instance-1:~$ qhost -q
HOSTNAME                ARCH         NCPU  LOAD  MEMTOT  MEMUSE  SWAPTO  SWAPUS
-------------------------------------------------------------------------------
global                  -               -     -       -       -       -       -
instance-1.c.analytical-rig-638.internal lx26-amd64      1  0.07    3.6G  133.9M     0.0     0.0
</pre><p> We don't have a fully working setup yet, we still need to configure it; we're just checking that the client can reach the master. At this point, any errors likely relate to DNS lookup, reverse DNS lookup, or your /etc/hostname or /etc/hosts files; GridEngine doesn't like it when these things are inconsistent. If you need to change the name of the master from what you told the installer, you may be able to do so by editing the file </p>
<pre class="fragment">/var/lib/gridengine/default/common/act_qmaster
</pre><p> (at least, this is where it's located in Debian Wheezy).</p>
<h2><a class="anchor" id="parallelization_gridengine_configuring"></a>
Configuring GridEngine</h2>
<p>First let's make sure that a queue is defined. GridEngine doesn't define any queues by default. We'll set up a queue called <code>all.q</code>. Make sure the shell variable <code>EDITOR</code> is set to your favorite shell (e.g. <code>vim</code> or <code>emacs</code>), and type as follows; and this should work from master or client. </p>
<pre class="fragment"> qconf -aq
</pre><p> This will bring up an editor. Edit the line </p>
<pre class="fragment">qname               template
</pre><p> so it says </p>
<pre class="fragment">qname               all.q
</pre><p> Also change the field <code>shell</code> from <code>/bin/csh</code> to <code>/bin/bash</code>; this is a better default, although it shouldn't affect Kaldi. Quitting the editor will save the changes, although if you made syntax errors, <code>qconf</code> will reject your edits. Later on we'll make more changes to this queue by typing <code>qconf -mq all.q</code>.</p>
<p>GridEngine stores some global configuration values, not connected with any queue, which can be viewed with <code>qconf -sconf</code>. We'll edit them using <code>qconf -mconf</code>. There is a line that reads </p>
<pre class="fragment">administrator_mail           root
</pre><p> and if you have sending emails working from your machine (i.e. you can type <code>mail foobar@gmail.com</code> and the mail gets delivered), then you can change <code>root</code> to an email address where you want to receive notifications if things go wrong. Be advised that due to anti-spam measures, sending emails from the cloud is painful from EC2 and close to impossible from Google's cloud offering, so it may be best just to leave this field the way it is and make do without email notifications. You could also edit the file so that it says </p>
<pre class="fragment">                      flush_time=00:00:10
</pre><p> (the default is <code>00:00:15</code>), which will give a slightly faster turnaround time for submitting jobs.</p>
<p>GridEngine has the concept of "resources" which can be requested or specified by your jobs, and these can be viewed using <code>qconf -sc</code>. Modify them using <code>qconf -mc</code>. Modify the <code>mem_free</code> line to change the default memory requirement from 0 to 1G, i.e.: </p>
<pre class="fragment">#name               shortcut    type        relop requestable consumable default  urgency
#------------------------------------------------------------------------------------------
&lt;snip&gt;
mem_free            mf         MEMORY      &lt;=    YES         NO         1G        0
</pre><p> and also add the following two new lines; it doesn't matter where in the file you add them. </p>
<pre class="fragment">#name               shortcut    type        relop requestable consumable default  urgency
#------------------------------------------------------------------------------------------
&lt;snip&gt;
gpu                 g           INT         &lt;=    YES         YES        0        10000
ram_free            ram_free    MEMORY      &lt;=    YES         JOB        1G       0
</pre><p> You'll only need the "gpu" field if you add GPUs to your grid; the ram_free is a field that we find useful in managing the memory of the machines, as the inbuilt field <code>mem_free</code> doesn't seem to work quite right for our purposes. Later on when we add hosts to the grid, we'll use the command <code>qconf -me &lt;some-hostname&gt;</code> to edit the <code>complex_values</code> field to read something like: </p>
<pre class="fragment"> complex_values        ram_free=112G,gpu=2
</pre><p> (for a machine with 112G of physical memory and 2 GPUs). If we want to submit a job that needs 10G of memory, we'll specify <code>-l mem_free=10G,ram_free=10G</code> as an option to <code>qsub</code>; the <code>mem_free</code> requirement makes sure the machine has that much free memory at the time the job starts, and the <code>ram_free</code> requirement makes sure we don't submit a lot of jobs requiring a lot of memory, all to the same host. We tried, as an alternative to adding the <code>ram_free</code> resource, using <code>qconf -mc</code> to edit the <code>consumable</code> field of the inbuilt <code>mem_free</code> resource to say <code>YES</code>, to make GridEngine keep track of memory requests; but this did not seem to work as desired. Note that both <code>ram_free</code> and <code>gpu</code> are names that we chose ourselves; they have no special meaning to GridEngine, while some of the inbuilt resources such as <code>mem_free</code> do have special meanings. The string <code>JOB</code> in the <code>consumable</code> entry for <code>ram_free</code> means that the <code>ram_free</code> resource is specified per job rather than per thread; this is more convenient for Kaldi scripts.</p>
<p>Next you have to have to add the parallel environment called <code>smp</code> to GridEngine. This is a kind of tradition in GridEngine setups, but it's not built-in. It's a simple parallel environment where GridEngine doesn't really do anything, it just reserves you a certain number of slots, so if you do <code>qsub -pe smp 10 &lt;your-script&gt;</code> you will get 10 CPU slots reserved; this can be useful for multi-threaded or multi-process jobs. Do <code>qconf -ap smp</code>, and edit the <code>slots</code> field to say 9999, so it reads: </p>
<pre class="fragment">pe_name            smp
slots              9999
...
</pre><p> Then do <code>qconf -mq all.q</code>, and edit the <code>pe_list</code> field by adding <code>smp</code>, so it reads: </p>
<pre class="fragment">pe_list               make smp
</pre><p> This enables the <code>smp</code> parallelization method in the queue <code>all.q</code>.</p>
<h2><a class="anchor" id="parallelization_gridengine_configuring_advanced"></a>
Configuring GridEngine (advanced)</h2>
<p>In this section we just want to make a note of some things that might be helpful, but which aren't necessary just to get things running. In the CLSP cluster, we edited the <code>prolog</code> field in <code>qconf -mq all.q</code> so that it says </p>
<pre class="fragment">prolog                /var/lib/gridengine/default/common/prolog.sh
</pre><p> (the default was <code>NONE</code>), and the script <code>/var/lib/gridengine/default/common/prolog.sh</code>, which we copied to that location on each individual node in the cluster, reads as follows. Its only purpose is to wait a short time if the job script can't be accessed, to give NFS some time to sync in case the scripts were written very recently and haven't yet propagated across the grid: </p>
<pre class="fragment">#!/bin/bash

function test_ok {
  if [ ! -z "$JOB_SCRIPT" ] &amp;&amp; [ "$JOB_SCRIPT" != QLOGIN ] &amp;&amp; [ "$JOB_SCRIPT" != QRLOGIN ]; then
    if [ ! -f "$JOB_SCRIPT" ]; then
       echo "$0: warning: no such file $JOB_SCRIPT, will wait" 1&gt;&amp;2
       return 1;
    fi
  fi
  if [ ! -z "$SGE_STDERR_PATH" ]; then
    if [ ! -d "`dirname $SGE_STDERR_PATH`" ]; then
      echo "$0: warning: no such directory $JOB_SCRIPT, will wait." 1&gt;&amp;2
      return 1;
    fi
  fi
  return 0;
}

if ! test_ok; then
  sleep 2;
  if ! test_ok; then
     sleep 4;
     if ! test_ok; then
        sleep 8;
     fi
  fi
fi

exit 0;
</pre><p> This script waits at most 14 seconds, which is enough because we configured <code>acdirmax=8</code> in our NFS options as the maximum wait before refreshing a cached directory (see <a class="el" href="queue.html#parallelization_grid_stable_nfs">Keeping your grid stable (NFS)</a> below).</p>
<p>We also edited the queue with <code>qconf -mq all.q</code> to change <code>rerun</code> from FALSE to TRUE, i.e. to say: </p>
<pre class="fragment">rerun                 TRUE
</pre><p> This means that when jobs fail, they get in a status that shows up in the output of <code>qstat</code> as <code>Eqw</code>, with the <code>E</code> indicating error, and you can ask the queue to reschedule them by clearing the error status with <code>qmod -cj &lt;numeric-job-id&gt;</code> (or if you don't want to rerun them, you can delete them with <code>qmod -dj &lt;numeric-job-id&gt;</code>). Setting the queue to allow reruns can avoid the hassle of rerunning scripts from the start when things break due to NFS problems.</p>
<p>Something else we did in the CLSP queue is to edit the following fields, which by default read: </p>
<pre class="fragment">rlogin_daemon                /usr/sbin/sshd -i
rlogin_command               /usr/bin/ssh
qlogin_daemon                /usr/sbin/sshd -i
qlogin_command               /usr/share/gridengine/qlogin-wrapper
rsh_daemon                   /usr/sbin/sshd -i
rsh_command                  /usr/bin/ssh
</pre><p> to read instead: </p>
<pre class="fragment">qlogin_command               builtin
qlogin_daemon                builtin
rlogin_command               builtin
rlogin_daemon                builtin
rsh_command                  builtin
rsh_daemon                   builtin
</pre><p> This was to solve a problem whose nature we can no longer recall, but it's something you might want to try it if commands like <code>qlogin</code> and <code>qrsh</code> don't work.</p>
<h2><a class="anchor" id="parallelization_gridengine_configuring_adding"></a>
Configuring GridEngine (adding nodes)</h2>
<p>In this section we address what you do when you add nodes to the queue. As mentioned above, you can install GridEngine on nodes by doing </p>
<pre class="fragment">  sudo apt-get install gridengine-client gridengine-exec
</pre><p> and you need to specify <code>default</code> as the cluster name, and the name of your master node as the master (probably using the FQDN of the master is safest here, but if you are on a local network, just the last part of the name may also work).</p>
<p>But that doesn't mean your machine is fully in the queue. GridEngine has separate notions of hosts being administrative hosts, execution hosts and submit hosts. All your machines should be all three. You can view which machines have these three roles using the commands <code>qconf -sh</code>, <code>qconf -sel</code>, and <code>qconf -ss</code> respectively. You can add your machine as an administrative or submit host with the commands: </p>
<pre class="fragment"> qconf -ah &lt;your-fqdn&gt;
 qconf -as &lt;your-fqdn&gt;
</pre><p> and you can add your host as an execution host with the command </p>
<pre class="fragment"> qconf -ae &lt;your-fqdn&gt;
</pre><p> which brings up an editor; you can put in the ram_free and possibly GPU fields in here, e.g. </p>
<pre class="fragment">complex_values    ram_free=112G,gpu=1
</pre><p> You'll notice is a slight asymmetry between the commands <code>qconf -sh</code> and <code>qconf -ss</code> on the one hand, and <code>qconf -sel</code> on the other. The <code>"l"</code> in the latter command means show the list. The difference is that administrative and submit host lists are just lists of hosts, whereas qconf stores a bunch of information about the execution hosts, so it views it as a different type of data structure. You can view the information about a particular host with <code>qconf -se &lt;some-hostname&gt;</code>, add a new host with <code>qconf -ae &lt;some-hostname</code>, and modify with <code>qconf -me &lt;some-hostname&gt;</code>. This is a general pattern in GridEngine: for things like queues that have a bunch of information in them, you can show the full list by typing a command ending in "l" like <code>qconf -sql</code>, and the corresponding "add" (<code>"a"</code>) and "modify" (<code>"m"</code>) commands accept arguments.</p>
<p>It's not enough to tell GridEngine that a node is an execution host; you have to also add it to the queue, and tell the queue how many slots to allocate for that node. First figure out how many CPUs (or virtual CPUs) your machine has, by doing: </p>
<pre class="fragment">grep proc /proc/cpuinfo | wc -l
</pre><p> Suppose this is 48. You can choose a number a little smaller than this, say 40, and use that for the number of slots. Edit the queue using <code>qconf -mq all.q</code>, add your machine to the hostlist, and set the number of slots. It should look like this: </p>
<pre class="fragment">qname                 all.q
hostlist              gridnode1.research.acme.com,gridnode2.research.acme.com
&lt;snip&gt;
slots                 30,[gridnode1.research.acme.com=48],[gridnode1.research.acme.com=48]
&lt;snip&gt;
</pre><p> In the <code>slots</code> field, the <code>30</code> at the beginning is a default value; for any nodes with that number of slots you can save yourself some time and avoid adding the node's name to the <code>slots</code> field. There is an alternative way to set up the <code>hostlist</code> field. GridEngine has the concept of host groups, so you could do <code>qconf -ahgrp @allhosts</code> to add a group of hosts, and edit it using <code>qconf -mhgrp @allhosts</code> to add your new nodes. The configuration of <code>all.q</code> could then just read: </p>
<pre class="fragment">hostlist            @allhosts
</pre><p> It's your choice. For simple queues, it's probably fine to just put the host list in the <code>all.q</code> configuration.</p>
<p>A useful command to list the hosts that GridEngine knows about, and what queues they are in, is <code>qhost -q</code>. For example: </p>
<pre class="fragment"># qhost -q
HOSTNAME                ARCH         NCPU  LOAD  MEMTOT  MEMUSE  SWAPTO  SWAPUS
-------------------------------------------------------------------------------
global                  -               -     -       -       -       -       -
a01.clsp.jhu.edu        lx26-amd64     24 12.46  126.2G   11.3G   86.6G  213.7M
   all.q                BIP   0/6/20
a02.clsp.jhu.edu        lx26-amd64     24 16.84  126.2G   12.4G   51.3G  164.5M
   all.q                BIP   0/18/20
&lt;snip&gt;
</pre><p> If you see the letter <code>"E"</code> in the place where the example above shows <code>"BIP"</code>, it means the node is in the error state. Other letters you don't want to see in that position are <code>"a"</code> for alarm (a generic indicator of badness) and <code>"u"</code> for unreachable. <code>"d"</code> means a node has been disabled by an administrator. Nodes sometimes get in the error (<code>"E"</code>) state when GridEngine had trouble running a job, which is often due to NFS or automount problems. You can clear the error by doing something like </p>
<pre class="fragment">qmod -c all.q@a01
</pre><p> but of course if the node has serious problems, it might be wise to fix them first. It's sometimes also useful to enable and disable nodes in the queue by doing </p>
<pre class="fragment">qmod -d all.q@a01
</pre><p> to disable a node, and <code>qmod -e all.q@a01</code> to enable it again.</p>
<p>A common symptom of GridEngine problems is jobs waiting when you think nodes are free. The easiest way to debug this is to look for the job-id in the output of <code>qstat</code>, and then to do <code>qstat -j &lt;job-id&gt;</code> and look for the reasons why the job is not running.</p>
<p>You can view all jobs from all users by running </p>
<pre class="fragment">qstat -u '*'
</pre><h1><a class="anchor" id="parallelization_grid_stable"></a>
Keeping your grid stable</h1>
<p>In this section we have some general notes on how to ensure stability in a compute cluster of the kind useful for Kaldi.</p>
<h2><a class="anchor" id="parallelization_grid_stable_oom"></a>
Keeping your grid stable (OOM)</h2>
<p>One of the major causes of crashes in compute clusters is memory exhaustion. The default OOM-killer in Linux is not very good, so if you exhaust memory, it may end up killing an important system process, which tends to cause hard-to-diagnose instability. Even if nothing is killed, <code>malloc()</code> may start failing when called from processes on the system; and very few programs deal with this gracefully. In the CLSP grid we wrote our own version of an OOM killer, which we run as root, and we wrote the corresponding init scripts. When our OOM killer detects memory overload, it kills the largest process of whichever non-system user is using the most memory. This is usually the right thing to do. These scripts have been made public as part of the <code>kluster</code> project, and you can get them as shown below if you want to add them to your system. The following commands will only work as-is if you have LSB-style init scripts, which is the case in Debian <code>wheezy</code>. The next Debian release, <code>jessie</code>, won't have init scripts at all and will use <code>systemd</code> instead (the so-called "systemd controversy"). If someone can figure out how to do the following in <code>systemd</code>, please let us know. Type </p>
<pre class="fragment">sudo bash
</pre><p> and then as root, do: </p>
<pre class="fragment">apt-get install -y subversion
svn cat https://svn.code.sf.net/p/kluster/code/trunk/scripts/sbin/mem-killer.pl &gt; /sbin/mem-killer.pl
chmod +x /sbin/mem-killer.pl
cd /etc/init.d
svn cat https://svn.code.sf.net/p/kluster/code/trunk/scripts/etc/init.d/mem-killer &gt;mem-killer
chmod +x mem-killer
update-rc.d mem-killer defaults
service mem-killer start
</pre><p> <code>mem-killer.pl</code> is capable of sending email to the administrators and to the person whose jobs was killed if something is wrong, but this will only work if your system can send mail, and if the user has put their email somewhere in the "office" field of their gecos information, using chfn (or ypchfn if using NIS). Again, if you're running in the cloud, it's best to forget about anything email-related, as it's too hard to get working.</p>
<h2><a class="anchor" id="parallelization_grid_stable_nfs"></a>
Keeping your grid stable (NFS)</h2>
<p>We aren't going to give a complete run-down of how to install NFS here, but we want to mention some potential issues, and explain some options that work well. Firstly, NFS is not the only option for a shared filesystem; there are some newer distributed file systems available too, but we don't have much experience with them.</p>
<p>NFS can perform quite badly if the options are wrong. Below are the options we use. We show it as if we're grepping it from /etc/fstab; this isn't actually how we do it (we actually use NIS and automount), but the following way is simpler: </p>
<pre class="fragment"># grep a05 /etc/fstab
a05:/mnt/data /export/a05 nfs rw,vers=3,rsize=8192,wsize=8192,acdirmin=5,acdirmax=8,hard,proto=tcp 0 0
</pre><p> The option "vers=3" means we use NFS version 3, which is stateless. We tried using version 4, a supposedly more advanced "stateful" protocol, but we got a lot of crashes.</p>
<p>The <code>acdirmin=5</code> and <code>acdirmin=8</code> options are the minimum and maximum times that NFS waits before re-reading cached directory information; the defaults are 30 and 60 seconds respectively. This is important for Kaldi scripts, because the files that we execute on GridEngine are written only shortly before we run the scripts, so with default NFS options they may not yet be visible on the execution host at the time they are needed. Above we showed our script <code>/var/lib/gridengine/default/common/prolog.sh</code> which waits up to 14 seconds for the script to appear. It's significant that 14 &gt; 8, i.e. that the number of seconds the prolog script will wait for is greater than the maximum directory caching period for NFS.</p>
<p>The <code>hard</code> option is also important; it means that if the server is busy, the client will wait for it to succeed rather than reporting an error (e.g. <code>fopen</code> returning error status). If you specify <code>soft</code>, Kaldi may crash. <code>hard</code> is the default so could be omitted.</p>
<p>The <code>proto=tcp</code> option is also the default on Debian currently; the alternative is <code>proto=udp</code>. The TCP protocol is important for stability when local networks may get congested; we have found this through experience.</p>
<p>The <code>rsize=8192,wsize=8192</code> are packet sizes; they are supposedly important in the performance of NFS. Kaldi reads and writes are generally contiguous and don't tend to seek much within files, so large packet size is probably suitable.</p>
<p>Another thing you might want to tune that's NFS related is the number of threads in the server. You can see this as follows: </p>
<pre class="fragment">/$ head /etc/default/nfs-kernel-server
# Number of servers to start up
RPCNFSDCOUNT=64
</pre><p> To change it you edit that file and then restart the service (<code>service nfs-kernel-server restart</code>, on Debian). Apparently it is not good for this to be less than the number of clients that might simultaneously access your server (although 64 is the upper limit of what I've seen people recommend to set this to). Apparently one way to tell if you have too few threads is too look at the <code>retrans</code> count in your NFS stats: </p>
<pre class="fragment">nfsstat -rc
Client rpc stats:
calls      retrans    authrefrsh
434831612   6807461    434979729
</pre><p> The stats above have a largish number of <code>retrans</code>, and apparently in the ideal case it should be zero. We had the number of NFS threads set to a lower number (24) for most of the time that machine was up, which was less than the potential number of clients, so it's not surprising that we had a high amount of <code>retrans</code>. What seems to happen is that if a large number of clients are actively using the server, especially writing large amounts of data simultaneously, they can tie up all the server threads and then when another client tries to do something, it fails and in the client logs you'll see something like <code>nfs: server a02 not responding, still trying</code>. This can sometimes be associated with crashed jobs, and if you use automount on your setup, it can sometimes cause jobs that are not even accessing that server to crash or be delayed (automount has a brain-dead, single-threaded design, so failure of one mount request can hang up all other automount reqeuests).</p>
<h2><a class="anchor" id="parallelization_grid_stable_misc"></a>
Keeping your grid stable (general issues)</h2>
<p>In this section we have some general observations about how to configure and manage a compute grid.</p>
<p>In CLSP we use a lot of NFS hosts, not just one or two; in fact, most of our nodes also export data via NFS. If you do this you should use our <code>mem-killer.pl</code> or a similar script, or you will get instability due to memory exhaustion when users make mistakes. Having a large number of file servers is a particularly good idea for queues that are shared by many people, because it's inevitable that people will overload file servers, and if there are only one or two file servers, the queue will end up being in a degraded state for much of the time. The network bandwidth of each individual file server at CLSP is quite slow: for cost reasons we still use 1G ethernet, but all connected to each other with an expensive Cisco router so that there is no global bottleneck. This means that each file server gets overloaded quite easily; but because there are so many individual file servers, this generally only inconveniences the person who is overloading it and maybe one or two others.</p>
<p>When we do detect that a particular file server is loaded (generally either by noticing slowness, or by seeing errors like <code>nfs: server a15 not responding</code> in the output of <code>dmesg</code>), we try to track down why this is happening. Without exception this is due to bad user behavior, i.e. users running too many I/O-heavy jobs. Usually through a combination of the output of <code>iftop</code> and the output of <code>qstat</code>, we can figure out which user is causing the problem. In order to keep the queue stable it's necessary to get users to correct their behavior and to limit the number of I/O heavy jobs they run, by sending them emails and asking them to modify their setups. If we didn't contact users in this way the queue would be unusable, because users would persist in their bad habits.</p>
<p>Many other groups have a lot of file servers, like us, but still have all their traffic going to one file server because they buy the file servers one at a time and they always allocate space on the most recently bought one. This is just stupid. In CLSP we avoid the administrator hassle of having to allocate space, by having all the NFS servers world-writable at the top level, and by instructing people to make directories with their userid on them, on a server of their choice. We set up scripts to notify the administrators by email when any of the file servers gets 95% full, and to let us know which directories contain a lot of data. We can then ask the users concerned to delete some data, or we delete it ourselves if the users are gone and if we feel it's appropriate. We also set up scripts to work out, queue-wide, which users are using the most space, and to send them emails informing them where they are consuming the most space. The administrators will also ask the users to clean up, particularly in extreme cases (e.g. when a junior student is using a huge amount of space for no obvious reason). Space should never really be a problem, because it's almost always the case that the disk is 95% full of junk that no-one cares about or even remembers. It's simply a matter of finding a way to ask those responsible to clean up, and making their life easy by telling them where the bulk of their data is.</p>
<p>Another useful thing is to locate home directories on a server that is not also used for experiments; this ensures that users can always get a prompt, even when other users are being stupid. It also makes the backup policy easier: we back up the home directories but not the NFS volumes used for experimental work, and we make clear to users that those volumes are not backed up (of course, students will still fail to back up their important data, and will sometimes lose it as a result). The ban on running experiments in home directories needs to be enforced; we frequently have to tell users to stop parallel jobs with data in their home directories. This is the most frequent cause of grid-wide problems. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Kaldi</a></li>
    <li class="footer">Generated on Thu Apr 28 2016 15:42:38 for Kaldi by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
