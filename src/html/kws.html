<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: Keyword Search in Kaldi</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('kws.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Keyword Search in Kaldi </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="kws_intro"></a>
Introduction</h1>
<p>This page describes the keyword search module in Kaldi. Our implementation includes the following features:</p>
<ul>
<li>Lattice indexing for fast keyword retrieval.</li>
<li>Proxy keywords to handle out-of-vocabulary (OOV) problem.</li>
</ul>
<p>In the following document, we will focus on word level keyword search for simplicity purpose, but our implementation naturally supports word level as well as subword level keyword search &ndash; both our LVCSR module and the KWS module are implemented using weighted finite state transducer (WFST), and the algorithm should work as long as the symbol table properly maps words/subwords to integers.</p>
<p>The rest of this document is organized as follows: in section <a class="el" href="kws.html#kws_system">Typical Kaldi KWS system</a>, we describe the basic components of a Kaldi KWS system; in section <a class="el" href="kws.html#kws_proxy">Proxy keywords</a>, we explain how we use proxy keywords to handle the keywords that are not in the vocabulary; finally in section <a class="el" href="kws.html#kws_scripts">Babel scripts</a>, we walk through the KWS related scripts we created for IARPA Babel project.</p>
<h1><a class="anchor" id="kws_system"></a>
Typical Kaldi KWS system</h1>
<p>An example of a Kaldi KWS system can be found in this paper <a href="http://www.clsp.jhu.edu/~guoguo/papers/icassp2013_lexicon_value.pdf">"Quantifying the Value of Pronunciation Lexicons for Keyword Search in Low Resource Languages", G. Chen, S. Khudanpur, D. Povey, J. Trmal, D. Yarowsky and O. Yilmaz</a>. Generally, a KWS system consists of two parts: a LVCSR module that decodes the search collection and generates corresponding lattices, and a KWS module that makes index for the lattices and searches the keywords from the generated index.</p>
<p>Our basic LVCSR system is a SGMM + MMI system. We use standard PLP analysis to extract 13 dimensional acoustic features, and follow a typical maximum likelihood acoustic training recipe, beginning with a flat-start initialization of context-independent phonetic HMMs, and ending with speaker adaptive training (SAT) of state-clustered triphone HMMs with GMM output densities. This is followed by the training of a universal background model from speaker-transformed training data, which is then used to train a subspace Gaussian mixture model (SGMM) for the HMM emission probabilities. Finally, all the training speech is decoded using the SGMM system, and boosted maximum mutual information (BMMI) training of the SGMM parameters is performed. More details can be found in egs/babel/s5b/run-1-main.sh.</p>
<p>We also build additional systems besides the basic SGMM + MMI system. For example, a hybrid deep neural network (DNN) system, details in egs/babel/s5b/run-2a-nnet-gpu.sh, a bottleneck feature system, details in egs/babel/s5b/run-8a-kaldi-bnf.sh, etc. All those systems decode and generate lattices for the same search collection, which will then be sent to the KWS module for indexing and searching. We do system combination on the retrieved results instend of lattices.</p>
<p>Lattices generated by the above LVCSR systems are processed using the lattice indexing technique described in <a href="https://wiki.inf.ed.ac.uk/twiki/pub/CSTR/ListenSemester2201314/taslp_2011.pdf">"Lattice indexing for spoken term detection", D. Can, M. Saraclar, Audio, Speech, and Language Processing</a>. The lattices of all the utterances in the search collection are converted from individual weighted finite state transducers (WFST) to a single generalized factor transducer structure in which the start-time, end-time and lattice posterior probability of each word token is stored as a 3-dimensional cost. This factor transducer is actually an inverted index of all word sequences seen in the lattices. Given a keyword or phrase, we then create a simple finite state machine that accepts the keyword/phrase and composes it with the factor transducer to obtain all occurrences of the keyword/phrase in the search collection, along with the utterance ID, start-time and end-time and lattice posterior probability of each occurrence. All those occurrences are sorted according to their posterior probabilities and a YES/NO decision is assigned to each instance using the method proposed in the paper "Rapid and Accurate Spoken Term Detection".</p>
<h1><a class="anchor" id="kws_proxy"></a>
Proxy keywords</h1>
<p>Our proxy keyword generation process has been described in this paper <a href="http://www.clsp.jhu.edu/~guoguo/papers/asru2013_proxy_keyword.pdf">"Using Proxies
for OOV Keywords in the Keyword Search Task", G. Chen, O. Yilmaz, J. Trmal, D. Povey, S. Khudanpur</a>. We originally proposed this method to solve the OOV problem of the word lattices &ndash; if a keyword is not in the vocabulary of the LVCSR system, it will not appear in the search collection lattices, even though the keyword is actually spoken in the search collection. This is a known problem of LVCSR based keyword search systems, and there are ways to handle this, for example, building a subword system. Our approach is to find acoustically similar in-vocabulary (IV) words for the OOV keyword, and use them as proxy keywords instead of the original OOV keyword. The advantage is that we do not have to build additional subword systems. In a upcoming Interspeech paper "Low-Resource Open Vocabulary Keyword Search Using Point
Process Models", C. Liu, A. Jansen, G. Chen, K. Kintzley, J. Trmal, S. Khudanpur, we show that this technique is comparable and complementary to a phonetic search method based on point process model. Proxy keyword is one of the fuzzy search methods, and it should also improve IV keyword performance, although we initially brought it up to handle OOV keywords.</p>
<p>The general proxy keyword generation process can be formulized as follows: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ K^\prime = \mathrm{Project} \left( \mathrm{ShortestPath} \left( \mathrm{Prune} \left( \mathrm{Prune} \left(K \circ L_2 \circ E^\prime \right) \circ L_1^{-1} \right) \right) \right) \]" src="form_13.png"/>
</p>
<p>where <img class="formulaInl" alt="$K$" src="form_14.png"/> is the original keyword, <img class="formulaInl" alt="$L_2$" src="form_15.png"/> is a lexicon that contains the pronunciation of <img class="formulaInl" alt="$K$" src="form_14.png"/>. If <img class="formulaInl" alt="$K$" src="form_14.png"/> is out of vocabulary, this lexicon can be obtained by using G2P tools such as Sequitur. <img class="formulaInl" alt="$E^\prime$" src="form_16.png"/> is the edit distance transducer that contains the phone confusions collectioned from training set, and <img class="formulaInl" alt="$L_1$" src="form_17.png"/> is the original lexicon. <img class="formulaInl" alt="$K^\prime$" src="form_18.png"/> is then a WFST that contains several IV words that are acoustically similar to the original keyword <img class="formulaInl" alt="$K$" src="form_14.png"/>. We plug it into the search pipeline "as if" it was the original keyword.</p>
<p>Note that the two pruning stages are essential, especially when you have a very large vocabulary. We also implemented a lazy-composition algorithm that only generates composed states as needed (i.e., does not generate states that will be pruned away later). This avoids blowing up the memory when composing <img class="formulaInl" alt="$K \circ L_2 \circ E^\prime$" src="form_19.png"/> with <img class="formulaInl" alt="$L_1^{-1}$" src="form_20.png"/>.</p>
<h1><a class="anchor" id="kws_scripts"></a>
Babel scripts</h1>
<h2><a class="anchor" id="kws_scripts_highlevel"></a>
A highlevel look</h2>
<p>We have set up the "push-button" scripts for IARPA Babel project. If you are working on Babel and want to use our scripts, you can build a SGMM + MMI keyword search system in the following steps (assume you are in working directory egs/babel/s5b/):</p>
<ul>
<li>Install F4DE and put it in your path.sh</li>
<li>Modify your cmd.sh so that it can run on your cluster</li>
<li>Link one of the config files in conf/languages to ./lang.conf, e.g., "ln -s conf/languages/105-turkish-limitedLP.official.conf lang.conf"</li>
<li>Modify lang.conf to point to your files instead the ones on JHU cluster</li>
<li>Run run-1-main.sh, which builds the LVCSR system</li>
<li>Run run-2-segmentation.sh, which generates segmentation for eval data</li>
<li>Run run-4-anydecode.sh, which decodes the eval data, makes the index and searches the keywords</li>
</ul>
<p>Similarly, you can build DNN systems, BNF systems, Semi-supervised systems, etc. The KWS stuff happens in run-4-anydecode.sh. We will have a detailed look of how to do keyword search below, in case you want to do keyword search for some other resources. We assume that you have decoded your search collection and generated the corresponding lattices.</p>
<h2><a class="anchor" id="kws_scripts_dataprep"></a>
Prepare KWS data</h2>
<p>Typically, we generate KWS data directories under the search collection data directory. For example, if you have a search collection called dev10h.uem, you will have a data directory for it called data/dev10h.uem/. We create KWS data directories under this directory, e.g., data/dev10h.uem/kws/. Before creating KWS data directories, you have to get three files ready by hand: a ecf file that contains the search collection information, a kwlist file that lists all the keywords and a rttm file for scoring. Sometimes you may have to prepare those files by yourself, for example, you can generate the rttm file by force aligning the search collection with a trained model. Below we show the format of those files.</p>
<p>Example ECF file: </p>
<pre class="fragment">&lt;ecf source_signal_duration="483.825" language="" version="Excluded noscore regions"&gt;
  &lt;excerpt audio_filename="YOUR_AUDIO_FILENAME" channel="1" tbeg="0.000" dur="483.825" source_type="splitcts"/&gt;
&lt;/ecf&gt;
</pre><p>Example KWLIST file: </p>
<pre class="fragment">&lt;kwlist ecf_filename="ecf.xml" language="tamil" encoding="UTF-8" compareNormalize="" version="Example keywords"&gt;
  &lt;kw kwid="KW204-00001"&gt;
    &lt;kwtext&gt;செய்றத&lt;/kwtext&gt;
  &lt;/kw&gt;
  &lt;kw kwid="KW204-00002"&gt;
    &lt;kwtext&gt;சொல்லுவியா&lt;/kwtext&gt;
  &lt;/kw&gt;
&lt;/kwlist&gt;
</pre><p>Example RTTM file: </p>
<pre class="fragment">SPEAKER YOUR_AUDIO_FILENAME 1 5.87 0.370 &lt;NA&gt; &lt;NA&gt; spkr1 &lt;NA&gt;
LEXEME YOUR_AUDIO_FILENAME 1 5.87 0.370 ஹலோ lex spkr1 0.5
SPEAKER YOUR_AUDIO_FILENAME 1 8.78 2.380 &lt;NA&gt; &lt;NA&gt; spkr1 &lt;NA&gt;
LEXEME YOUR_AUDIO_FILENAME 1 8.78 0.300 உம்ம் lex spkr1 0.5
LEXEME YOUR_AUDIO_FILENAME 1 9.08 0.480 அதான் lex spkr1 0.5
LEXEME YOUR_AUDIO_FILENAME 1 9.56 0.510 சரியான lex spkr1 0.5
LEXEME YOUR_AUDIO_FILENAME 1 10.07 0.560 மெசேஜ்டா lex spkr1 0.5
LEXEME YOUR_AUDIO_FILENAME 1 10.63 0.350 சான்ஸே lex spkr1 0.5
LEXEME YOUR_AUDIO_FILENAME 1 10.98 0.180 இல்லயே lex spkr1 0.5
</pre><p>With the above three files ready, you can start preparing KWS data directory. If you just want to do a basic keyword search, running the following should be enough: </p>
<pre class="fragment">local/kws_setup.sh \
  --case_insensitive $case_insensitive \
  --rttm-file $my_rttm_file \
  $my_ecf_file $my_kwlist_file data/lang $dataset_dir
</pre><p>If you want to do fuzzy search for your OOV keywords, you can run the following few commands, which first collects the phone confusions, and trains a G2P model, and then creates the KWS data directory: </p>
<pre class="fragment">#Generate the confusion matrix
#NB, this has to be done only once, as it is training corpora dependent,
#instead of search collection dependent
if [ ! -f exp/conf_matrix/.done ] ; then
  local/generate_confusion_matrix.sh --cmd "$decode_cmd" --nj $my_nj  \
    exp/sgmm5/graph exp/sgmm5 exp/sgmm5_ali exp/sgmm5_denlats  exp/conf_matrix
  touch exp/conf_matrix/.done
fi
confusion=exp/conf_matrix/confusions.txt

if [ ! -f exp/g2p/.done ] ; then
  local/train_g2p.sh  data/local exp/g2p
  touch exp/g2p/.done
fi
local/apply_g2p.sh --nj $my_nj --cmd "$decode_cmd" \
  --var-counts $g2p_nbest --var-mass $g2p_mass \
  $kwsdatadir/oov.txt exp/g2p $kwsdatadir/g2p
L2_lex=$kwsdatadir/g2p/lexicon.lex

L1_lex=data/local/lexiconp.txt
local/kws_data_prep_proxy.sh \
  --cmd "$decode_cmd" --nj $my_nj \
  --case-insensitive true \
  --confusion-matrix $confusion \
  --phone-cutoff $phone_cutoff \
  --pron-probs true --beam $beam --nbest $nbest \
  --phone-beam $phone_beam --phone-nbest $phone_nbest \
  data/lang  $data_dir $L1_lex $L2_lex $kwsdatadir
</pre><h2><a class="anchor" id="kws_scripts_index_and_search"></a>
Indexing and searching</h2>
<p>At this stage we assume you have decoded your search collection and generated the corresponding lattices. Running the following script will take care of indexing and searching: </p>
<pre class="fragment">local/kws_search.sh --cmd "$cmd" \
  --max-states ${max_states} --min-lmwt ${min_lmwt} \
  --max-lmwt ${max_lmwt} --skip-scoring $skip_scoring \
  --indices-dir $decode_dir/kws_indices $lang_dir $data_dir $decode_dir
</pre><p>If your KWS data directory has an extra ID, e.g., oov (this is useful when you have different KWS setups, in this case, your directory will look something like data/dev10h.uem/kws_oov), you have to run it with the extraid option: </p>
<pre class="fragment">local/kws_search.sh --cmd "$cmd" --extraid $extraid  \
  --max-states ${max_states} --min-lmwt ${min_lmwt} \
  --max-lmwt ${max_lmwt} --skip-scoring $skip_scoring \
  --indices-dir $decode_dir/kws_indices $lang_dir $data_dir $decode_dir
</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Kaldi</a></li>
    <li class="footer">Generated on Thu Apr 28 2016 15:42:38 for Kaldi by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
