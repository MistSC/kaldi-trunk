<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: Finite State Transducer algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('fst_algo.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Finite State Transducer algorithms </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Here we describe the FST algorithms in the Kaldi toolkit that are new or different than the the ones in OpenFst (we use the OpenFst code itself for many algorithms).</p>
<p>These algorithms are in the directory fstext/, and the corresponding command-line programs, where they exist, are in fstbin/. This code uses the OpenFst library. We will only describe here the algorithms that are actually used in our current recipes.</p>
<h1><a class="anchor" id="fst_algo_det"></a>
Determinization</h1>
<p>We use a different determinization algorithm from the one in OpenFst. We distinguish this with the name <a class="el" href="group__fst__extensions.html#gac6d4823e83f5353ae5b5ce569a7a29a3" title="This function implements the normal version of DeterminizeStar, in which the output strings are repre...">DeterminizeStar()</a>; the corresponding command-line program is named fstdeterminizestar. Our determinization algorithm is actually closer to the standard FST determinization algorithm than the one in OpenFst, in that it does epsilon removal along with determinization (thus, like many other FST algorithms, we do not consider epsilon to be a "real symbol".</p>
<p>Our determinization algorithm has a different way of handling what happens when a transition in the initial determinized output has more than one output symbol on it. The OpenFst determinization algorithm uses a function called FactorWeights that moves around the output symbols (encoded as weights) around while maintaining equivalence, in order to ensure that no arc has more than one (encoded) output symbol; it does not introduce new states with epsilon symbols on their input, which is the most "obvious" thing to do. However, the FactorWeights algorithm can fail for the output of DeterminizeStar, because there can be cycles with more outputs than states on the cycle (this is not possible for the output of the normal Determinize algorithm, because it does not do epsilon removal). Instead, whenever we encounter a link with more than one output symbols, we create a chain with a sufficient number of intermediate states to accommodate all the output symbols. The weight and input symbol go on the first link of this chain. The output of our DeterminizeStar algorithm is deterministic according to the definitions OpenFst uses, i.e. treating epsilons as a normal symbols. Its output does have epsilons on the input side, which is against the normal definition of determinism, but this is to be viewed as an encoding mechanism for allowing more than one output symbol on a link, and in any case it only happens in quite specific circumstances (an epsilon arc is always the only arc out of a state).</p>
<p>One other difference is that our program fstdeterminizestar does not require the input FST to have its output symbols encoded as weights.</p>
<h2><a class="anchor" id="fst_algo_det_debug"></a>
Debugging determinization</h2>
<p>In general debugging determinization is quite hard, because when a process takes a long time it's hard to tell whether ever terminate. The program fstdeterminizestar has the feature that if you send it a signal with "kill -SIGUSR1 \&lt;its processid\&gt;", it will stop and print out some information that can be useful for debugging the determinization.</p>
<h2><a class="anchor" id="fst_algo_det_log"></a>
Determinization in the log semiring</h2>
<p>We supply a function <a class="el" href="namespacefst.html#ad8a27fbfa6636ccb12785e01bb3ed685">DeterminizeInLog()</a> which casts an <a class="el" href="classFst.html">Fst</a> in the normal (tropical) semiring to the log semiring before determinizing, and then converts back. This is the form of determinization used in our algorithms, as it preserves stochasticity (see <a class="el" href="fst_algo.html#fst_algo_stochastic">Preserving stochasticity and testing it</a>).</p>
<h1><a class="anchor" id="fst_algo_eps"></a>
Removing epsilons</h1>
<p>We supply an epsilon-removal algorithm called <a class="el" href="namespacefst.html#aa21bb5fdd25868b9fd813a15f37aef8e" title="RemoveEpsLocal remove some (but not necessarily all) epsilons in an FST, using an algorithm that is g...">RemoveEpsLocal()</a> that is guaranteed to never blow up the FST, but on the other hand is not guaranteed to remove all epsilons. Essentially it removes whatever epsilons it can easily remove without making the graph larger. There is no optimality guaranteed here, as this is a hard problem. The <a class="el" href="namespacefst.html#aa21bb5fdd25868b9fd813a15f37aef8e" title="RemoveEpsLocal remove some (but not necessarily all) epsilons in an FST, using an algorithm that is g...">RemoveEpsLocal()</a> function has slightly different behaviour from OpenFst's RemoveEps() function, because it will combine two arcs if one has an input epsilon and one an output epsilon. The function <a class="el" href="namespacefst.html#aa21bb5fdd25868b9fd813a15f37aef8e" title="RemoveEpsLocal remove some (but not necessarily all) epsilons in an FST, using an algorithm that is g...">RemoveEpsLocal()</a> preserves FST equivalence.</p>
<p>There is also a function <a class="el" href="namespacefst.html#aae64b4835d6f9be3bcf646e644542ef8" title="As RemoveEpsLocal but takes care to preserve stochasticity when cast to LogArc. ">RemoveEpsLocalSpecial()</a> that preserves equivalence in the tropical semiring while preserving stochasticity in the log semiring (for more on stochasticity see next section). This appears to be a case where the usefulness of the semiring formalism breaks down a little bit, as we have to consider two semirings simultaneously.</p>
<h1><a class="anchor" id="fst_algo_stochastic"></a>
Preserving stochasticity and testing it</h1>
<p>We define a stochastic FST as an FST in which, in the FST's semiring the sum of the weights of the arcs out of any given state (plus the final-weight) equals one (in the semiring). This concept is most useful and natural in the log semiring; essentially, a stochastic FST is one where the sum of the weights out of a given arc is one (e.g. a properly normalized HMM would correspond to a stochastic FST).</p>
<p>The function <a class="el" href="namespacefst.html#a05555697346e1b408792565dde384b77">IsStochasticFst()</a> tests stochasticity. Optionally it can output minimum and maximum weights, to inform the user of the extent to which the FST fails to be stochastic. The command-line version of this is fstisstochastic. We aim for most of the FST algorithms we use to preserve stochasticity, in the sense that they will produce stochastic outputs given stochastic inputs. For non-stochastic inputs, we aim that the minimum and maximum range of the weights will not get larger. By default the program isstochasticfst will test stochasticity after casting to the log semiring, as this is the most useful case (you can stop this by supplying the option &ndash;test-in-log=false).</p>
<p>In order to preserve stochasticity, the FSTs that we compose with have to have certain properties. These should apply to L, C and H. Consider L, for example. We require that for any linear FST corresponding to a path through G, call this FST F, the product L o F must be stochastic. This basically means that L have properly normalized pronunciation probabilities. The actual property formally required may be a little stronger than this (this relates to ensuring that the probabilities appear at the "right time"). In practice we verify stochasticity by running the program isstochasticfst for each stage of graph creation.</p>
<h1><a class="anchor" id="fst_algo_minimization"></a>
Minimization</h1>
<p>We use the minimization algorithm supplied by OpenFst, but we apply a patch before compiling OpenFst so that minimization can be applied to non-deterministic FSTs. The reason for this is so that we can remove disambiguation symbols before minimizing, which is more optimal (it allows minimization to combine more states). The patch fixes data-structure related issues; fundamentally, OpenFst's minimization algorithm is applicable to non-deterministic FSTs. We supply a command-line program called fstminimizeencoded that minimizes FSTs after encoding weights and output symbols as part of the input symbols (so the FST becomes an acceptor). This is the same thing the fstminimize program does except that it does not do weight pushing. This is desirable for us because the way we ensure stochasticity entails avoiding any weight pushing.</p>
<h1><a class="anchor" id="fst_algo_composition"></a>
Composition</h1>
<p>For the most part we use OpenFst's own composition algorithms, but we do make use of a function <a class="el" href="namespacefst.html#aa4121807cfc94de5efb2420716093ca6">TableCompose()</a>, and a corresponding command-line program fsttablecompose, which is a more efficient composition algorithm for certain common cases. It uses the "Matcher" concept of OpenFst; a Matcher is a kind of helper class used during composition that performs lookup on the arcs out of a state to find any arcs with a particular input or output symbol. The normal matcher that OpenFst uses is SortedMatcher, which relies on arcs being sorted on the relevant label, and does a binary search. TableMatcher detects cases where it would be efficient to build a table indexed by label, and for those states it avoids the overhead of binary search. This leads to a speedup when composing with things like lexicons that have a very high out-degree.</p>
<h1><a class="anchor" id="fst_algo_disambig"></a>
Adding and removing disambiguation symbols</h1>
<p>Our FST recipes (like other transducer-based recipes) rely on disambiguation symbols. In the normal recipes, these are added to the input side of the lexicon FST (L) to make it determizable. We also add disambiguation symbols to G and C (see <a class="el" href="graph.html#graph_disambig">Disambiguation symbols</a>). Whenever we do a composition and the FST on the right has disambiguation symbols on its input, we (in theory) add to each state in the left-hand FST a self-loop for each of the disambiguation symbols, which has that symbol on both its input and output. Note that the actual integer symbols id's for the disambiguation symbols on the left and right may not be the same. For instance, we have a special symbol #0 in G (where epsilon would normally be). The symbol-id for this would generally be the highest-numbered word plus one. But when we want to pass this symbol through L, we need a symbol in L's input symbol table (which mainly contains phones), to represent #0. We have a function <a class="el" href="group__hmm__group__graph.html#ga938df29bca5ca1f3954733b5c3c53dc6" title="For context, see AddSelfLoops(). ">AddSelfLoops()</a> that takes a mutable FST and two vectors of labels (a label is an integer id for a symbol). The vectors are the same size, and represent corresponding input and output labels for the disambiguation symbols. This function adds self-loops to each final state and each state with non-epsilon output symbols on at least one arc out of it.</p>
<p>We remove disambiguation symbols with the function <a class="el" href="namespacefst.html#ad573c7b2172714c534c18d58ec0dd93a">DeleteISymbols()</a>, accessible on the command line with the program fstrmsymbols. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Kaldi</a></li>
    <li class="footer">Generated on Thu Apr 28 2016 15:42:38 for Kaldi by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
