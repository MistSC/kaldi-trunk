<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: Decoders used in the Kaldi toolkit</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('decoders.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Decoders used in the Kaldi toolkit </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In the Kaldi toolkit there is no single "canonical" decoder, or a fixed interface that decoders must satisfy.</p>
<p>There are currently two decoders available: <a class="el" href="classkaldi_1_1SimpleDecoder.html" title="Simplest possible decoder, included largely for didactic purposes and as a means to debug more highly...">SimpleDecoder</a> and <a class="el" href="classkaldi_1_1FasterDecoder.html">FasterDecoder</a>; and there are also lattice-generating versions of these (see <a class="el" href="decoders.html#decoders_lattice">Lattice generating decoders</a>). By "decoder" we mean the internal code of the decoder; there are command-line programs that wrap these decoders so that they can decode particular types of model (e.g. GMMs), or with particular special conditions (e.g. multi-class fMLLR). Examples of command-line programs that decode are gmm-decode-simple, gmm-decode-faster, gmm-decode-kaldi, and gmm-decode-faster-fmllr. We have avoided creating a single command-line program that can do every possible kind of decoding, as this could quickly become hard to modify and debug.</p>
<h1><a class="anchor" id="decodable_interface"></a>
The Decodable interface</h1>
<p>In order to minimize the interaction between the decoder and the acoustic modeling code, we have created a base class (<a class="el" href="classkaldi_1_1DecodableInterface.html" title="DecodableInterface provides a link between the (acoustic-modeling and feature-processing) code and th...">DecodableInterface</a>) which mediates between the decoder and the acoustic modeling code. The <a class="el" href="classkaldi_1_1DecodableInterface.html" title="DecodableInterface provides a link between the (acoustic-modeling and feature-processing) code and th...">DecodableInterface</a> object can be viewed as a wrapper for the pair (acoustic model, feature file). This might seem a slightly unnatural object. However, there is a good reason for its existence. The interaction between the acoustic model and the features can be quite complex (think about adaptation with multiple transforms), and by taking this out of the decoder we substantially simplify what the decoder has to know. The <a class="el" href="classkaldi_1_1DecodableInterface.html" title="DecodableInterface provides a link between the (acoustic-modeling and feature-processing) code and th...">DecodableInterface</a> object can be thought of as a matrix of size (number of frames) by (number of nonzero input labels on the graph).</p>
<p>The basic operation of a decoder is to "decode this object of type DecodableInterface".</p>
<p>The <a class="el" href="classkaldi_1_1DecodableInterface.html" title="DecodableInterface provides a link between the (acoustic-modeling and feature-processing) code and th...">DecodableInterface</a> object has only three functions: </p>
<pre class="fragment">  virtual BaseFloat LogLikelihood(int32 frame, int32 index);
  virtual int32 NumFramesReady() const;
  virtual bool IsLastFrame(int32 frame);
  virtual int32 NumIndices();
</pre><p> The function <a class="el" href="classkaldi_1_1DecodableInterface.html#a0fea536380fa24a5ffe6a7ca08633a03">LogLikelihood()</a> returns the log-likelihood for this frame and index; the index would normally be the (one-based) transition-id, see <a class="el" href="hmm.html#transition_model_identifiers">Integer identifiers used by TransitionModel</a>. The frame is a zero-based quantity. The most normal <a class="el" href="classkaldi_1_1DecodableInterface.html" title="DecodableInterface provides a link between the (acoustic-modeling and feature-processing) code and th...">DecodableInterface</a> object will just look up the appropriate feature vector (using the index "frame"), work out the pdf-id corresponding to that transition-id, and return the corresponding acoustic log-likelihood. Acoustic probability scales are also applied by the <a class="el" href="classkaldi_1_1DecodableInterface.html" title="DecodableInterface provides a link between the (acoustic-modeling and feature-processing) code and th...">DecodableInterface</a> object, but they are not part of its generic interface because the interface represents the minimum that the decoder "needs to know", and it does not need to know about the probability scales.</p>
<p>The <a class="el" href="classkaldi_1_1DecodableInterface.html#a016096adfe1a1c2c2f557c8c7be596e1">NumFramesReady()</a> function returns the number of frames currently available. In an offline, batch-mode setting this will equal the number of frames in the file. In an online setting this will be the number of frames we have already captured and processed into features, and it will likely increase with time. The <a class="el" href="classkaldi_1_1DecodableInterface.html#a9e2dede1c20fce727f2666fe45a06ab3">IsLastFrame()</a> function is an older mechanism for online decoding; it returns true if the given frame is the last one (in the old online-decoding mechanism, which is still supported for back compatibility, the call to the IsLastFrame() function would block if it was not the last frame but the data was not yet available.</p>
<h1><a class="anchor" id="decoders_simple"></a>
SimpleDecoder: the simplest possible decoder</h1>
<p>As an illustration of a "prototypical" decoder, consider the class <a class="el" href="classkaldi_1_1SimpleDecoder.html" title="Simplest possible decoder, included largely for didactic purposes and as a means to debug more highly...">SimpleDecoder</a>. This very simple decoder has been included mostly for reference and for debugging more highly optimized decoders.</p>
<h2><a class="anchor" id="decoders_simple_itf"></a>
Interface of SimpleDecoder</h2>
<p>The constructor of <a class="el" href="classkaldi_1_1SimpleDecoder.html" title="Simplest possible decoder, included largely for didactic purposes and as a means to debug more highly...">SimpleDecoder</a> takes the FST to decode with, and a decoding beam: </p>
<pre class="fragment">  SimpleDecoder(const fst::Fst&lt;fst::StdArc&gt; &amp;fst, BaseFloat beam);
</pre><p> Decoding an utterance is accomplished by the following function: </p>
<pre class="fragment">  void Decode(DecodableInterface &amp;decodable);
</pre><p> Here is an example code fragment where we construct a Decodable object and decode it: </p>
<pre class="fragment">  DecodableAmDiagGmmScaled gmm_decodable(am_gmm, trans_model, features,
                                         acoustic_scale);
  decoder.Decode(gmm_decodable);
</pre><p> The type <a class="el" href="classkaldi_1_1DecodableAmDiagGmmScaled.html">DecodableAmDiagGmmScaled</a> is a very simple object that, given a transition-id, works out from trans_model (type: <a class="el" href="classkaldi_1_1TransitionModel.html">TransitionModel</a>) the appropriate pdf-id, gets the corresponding row from the features (type: <a class="el" href="classkaldi_1_1Matrix.html">Matrix&lt;BaseFloat&gt;</a>), works out the likelihood from am_gmm (type: <a class="el" href="classkaldi_1_1AmDiagGmm.html">AmDiagGmm</a>), and scales it by acoustic_scale (type: float).</p>
<p>After calling this, we can get the traceback with the following call: </p>
<pre class="fragment">  bool GetBestPath(Lattice *fst_out);
</pre><p> The output is formatted as a lattice but contains only one path. The lattice is a finite-state transducer whose input and output labels are whatever labels were on the FST (typically transition-ids and words, respectively), and whose weights contain the acoustic, language model and transition weights.</p>
<h2><a class="anchor" id="decoders_simple_workings"></a>
How SimpleDecoder works</h2>
<p>This decoder stores tracebacks at the token level that are garbage collected. The token is of type <a class="el" href="classkaldi_1_1SimpleDecoder_1_1Token.html">SimpleDecoder::Token</a>, which has the following member variables: </p>
<pre class="fragment">  class Token {
   public:
    Arc arc_;
    Token *prev_;
    int32 ref_count_;
    Weight weight_;
    ...
</pre><p> The member of type Arc (this is a typedef to <a class="el" href="namespacefst.html#a70478eb2428a9406e4692d19a7a3a97f">fst::StdArc</a>) is a copy of the arc in the original FST, except it has the acoustic likelihood contribution added in. It contains the input and output labels, the weight and the next state (in the FST). The "prev_" member is the traceback; the "ref_count_" is used in the garbage collection algorithm; the "Weight" is a typedef to fst::StdArc::Weight but essentially it just stores a floating-point value which represents the accumulated cost up to this point.</p>
<p>Class <a class="el" href="classkaldi_1_1SimpleDecoder.html" title="Simplest possible decoder, included largely for didactic purposes and as a means to debug more highly...">SimpleDecoder</a> contains just four data members, declared as follows: </p>
<pre class="fragment">  unordered_map&lt;StateId, Token*&gt; cur_toks_;
  unordered_map&lt;StateId, Token*&gt; prev_toks_;
  const fst::Fst&lt;fst::StdArc&gt; &amp;fst_;
  BaseFloat beam_;
</pre><p> The last two of these (the FST and the beam) are constant during decoding. The members "cur_toks_" and "prev_toks_" store the currently active tokens for the current and previous frame respectively. The central loop of the <a class="el" href="classkaldi_1_1SimpleDecoder.html#ac78620c576a40d3bdb14dc87b2a754a5">Decode()</a> function is as follows: </p>
<pre class="fragment">for(int32 frame = 0; !decodable.IsLastFrame(frame-1); frame++) {
  ClearToks(prev_toks_);
  std::swap(cur_toks_, prev_toks_);
  ProcessEmitting(decodable, frame);
  ProcessNonemitting();
  PruneToks(cur_toks_, beam_);
}
</pre><p> These statements are all self-explanatory except for ProcessEmitting() and ProcessNonemitting(). The ProcessEmitting() function propagates tokens from prev_toks_ (i.e. the previous frame) to cur_toks_ (i.e. the current frame). It only considers emitting arcs (i.e. arcs with nonzero input label). For each token (say "tok") in prev_toks_, it looks at the state associated with the token (in tok-&gt;arc_.nextstate), and for each arc out of that state that is emitting, it creates a new token with a traceback to "tok" and with an "arc_" field coped from that arc, except with the associated weight updated to include the acoustic contribution. The "weight_" field, representing the accumulated cost up to this point, will be the sum (the product, in the semiring interpretation) of tok-&gt;weight_ and the weight of the recently added arc. Each time we attempt to add a new token to "cur_toks_", we have to make sure there is no existing token associated with the same FST state. If there is, we keep only the best.</p>
<p>The function ProcessNonemitting() deals only with cur_toks_ and not with prev_toks_; it propagates nonemitting arcs, i.e. arcs with zero/&lt;eps&gt; as the input label/symbol. The newly created tokens will point back to other tokens in cur_toks_. The weights on the arcs will just be the weights from the FST. ProcessNonemitting() may have to process chains of epsilons. It uses a queue to store states that need to be processed.</p>
<p>After decoding, the function <a class="el" href="namespacekaldi.html#a16fbd0e97a7e1964c9c946fbeffc0651">GetOutput()</a>, discussed above, will trace back from the most likely token at the final state (taking into account its final probability, if is_final==true), and produce a linear FST with one arc for each arc in the traceback sequence. There may be more of these than the number of frames, since there are separate tokens created for nonemitting arcs.</p>
<h1><a class="anchor" id="decoders_faster"></a>
FasterDecoder: a more optimized decoder</h1>
<p>The decoder <a class="el" href="classkaldi_1_1FasterDecoder.html">FasterDecoder</a> has almost exactly the same interface as <a class="el" href="classkaldi_1_1SimpleDecoder.html" title="Simplest possible decoder, included largely for didactic purposes and as a means to debug more highly...">SimpleDecoder</a>. The only important new configuration value is "max-active", which controls the maximum number of states that can be active at one time. Apart from enforcing the max-active states, the only major difference is a data-structure related one. We replace the type std::unordered_map&lt;StateId, Token*&gt; with a new type <a class="el" href="classkaldi_1_1HashList.html">HashList&lt;StateId, Token*&gt;</a>, where <a class="el" href="classkaldi_1_1HashList.html">HashList</a> is our own templated type created for this purpose. <a class="el" href="classkaldi_1_1HashList.html">HashList</a> stores a singly-linked-list structure whose elements are also accessible via a hash table, and it offers the capability to free up the hash table for a new list structure while giving sequential access to the old list structure. This is so that we can use the hash table to access what in <a class="el" href="classkaldi_1_1SimpleDecoder.html" title="Simplest possible decoder, included largely for didactic purposes and as a means to debug more highly...">SimpleDecoder</a> was cur_toks_, while still having access to what in <a class="el" href="classkaldi_1_1SimpleDecoder.html" title="Simplest possible decoder, included largely for didactic purposes and as a means to debug more highly...">SimpleDecoder</a> was prev_toks_, in the form of a list.</p>
<p>The main pruning step <a class="el" href="classkaldi_1_1FasterDecoder.html">FasterDecoder</a> takes place in ProcessEmitting. Conceptually what is happening is that we take the tokens in what in <a class="el" href="classkaldi_1_1SimpleDecoder.html" title="Simplest possible decoder, included largely for didactic purposes and as a means to debug more highly...">SimpleDecoder</a> was prev_toks_, and just before ProcessEmitting we prune using the beam and specified maximum number of active states (whichever is tighter). The way this is actually implemented is that we call a function <a class="el" href="classkaldi_1_1FasterDecoder.html#a29b7ac06ac090f20b696c56cf6dbc00b">GetCutoff()</a>, which returns a weight cutoff value "weight_cutoff" that corresponds to the tighter of these two criteria; this cutoff value applies to the tokens in prev_toks_. Then when we go through prev_toks_ (this variable does not exist in <a class="el" href="classkaldi_1_1FasterDecoder.html">FasterDecoder</a>, but conceptually), we only process those tokens better than the cutoff.</p>
<p>The code in <a class="el" href="classkaldi_1_1FasterDecoder.html">FasterDecoder</a> as it relates to cutoffs is a little more complicated than just having the one pruning step. The basic observation is this: it's pointless to create a very large number of tokens if you are only going to ignore most of them later. So the situation in ProcessEmitting is: we have "weight_cutoff" but wouldn't it be nice if we knew what the value of "weight_cutoff" on the next frame was going to be? Call this "next_weight_cutoff". Then, whenever we process arcs that have the current frame's acoustic likelihoods, we could just avoid creating the token if the likelihood is worse than "next_weight_cutoff". In order to know the next weight cutoff we have to know two things. We have to know the best token's weight on the next frame, and we have to know the effective beam width on the next frame. The effective beam width may differ from "beam" if the "max_active" constraint is limiting, and we use the heuristic that the effective beam width does not change very much from frame to frame. We attempt to estimate the best token's weight on the next frame by propagating the currently best token (later on, if we find even better tokens on the next frame we will update this estimate). We get a rough upper bound on the effective beam width on the next frame by using the variable "adaptive_beam". This is always set to the smaller of "beam" (the specified maximum beam width), or the effective beam width as determined by max_active, plus beam_delta (default value: 0.5). When we say it is a "rough upper bound" we mean that it will usually be greater than or equal to the effective beam width on the next frame. The pruning value we use when creating new tokens equals our current estimate of the next frame's best token, plus "adaptive_beam". With finite "beam_delta", it is possible for the pruning to be stricter than dictated by the "beam" and "max_active" parameters alone, although at the value 0.5 we do not believe this happens very often.</p>
<h1><a class="anchor" id="decoders_biglm"></a>
BiglmDecoder: decoding with large language models.</h1>
<p>There are two basic ways in Kaldi to use large language models (i.e. language models larger than a few million arcs, for which it would be difficult to successfully build the decoding graph). One way is to generate a lattice using a small LM, and to rescore this lattice with a large LM (see <a class="el" href="decoders.html#decoders_lattice">Lattice generating decoders</a> below, and also <a class="el" href="lattices.html">Lattices in Kaldi</a>). The other way is to use a "biglm" decoder, e.g. <a class="el" href="classkaldi_1_1BiglmFasterDecoder.html">BiglmFasterDecoder</a>. The basic idea is to create the decoding graph HCLG with a small grammar, and compose dynamically with the difference between a large grammar and the small grammar. Note that while we use the word "grammar" for compatibility with the standard notation, we have in mind a statistical language model. Imagine that the small grammar is G (an FST), and the large one is G'. The basic idea is to search, in decoding time, the graph formed by the triple composition <img class="formulaInl" alt="$ HCLG \circ G^- \circ G' $" src="form_1.png"/>, where <img class="formulaInl" alt="$G^T-$" src="form_2.png"/> is like <img class="formulaInl" alt="$G$" src="form_3.png"/> but with its scores negated. We'll give the high-level idea of how we do this first. We construct an on-demand composed FST, call it F, which is <img class="formulaInl" alt="$F = G^- \circ G' $" src="form_4.png"/>. Then while decoding, we construct on-demand the FST <img class="formulaInl" alt="$HCLG \circ F$" src="form_5.png"/>. The problem with this is that we would always take the worst-scoring path through G, e.g. improperly take the backoff arc, which would make the subtraction of the original FST scores incorrect.</p>
<p>The way we solve the problem above is to use some knowledge about the structure of $G$ and $G'$ (we assume they are are ARPA-style language models), and treat them as epsilon-free, deterministic FSTs. That is: when searching for an arc from a particular state with a particular input label, if we find that input label we take it (and return just that arc), otherwise we follow the epsilon transition, and recursively look for an arc with that label. In terms of the external interface of the FST, it looks like there was an arc from the original state (i.e. it looks like a language model FST that has been subjected to epsilon removal). We created a special interface for this type of FST, which we call <a class="el" href="classfst_1_1DeterministicOnDemandFst.html" title="class DeterministicOnDemandFst is an &quot;FST-like&quot; base-class. ">fst::DeterministicOnDemandFst</a>; it has a new function GetArc(), which finds the arc with a particular input label, if it exists (by assumption, there cannot be more than one). Both G and G' are of type <a class="el" href="classfst_1_1DeterministicOnDemandFst.html" title="class DeterministicOnDemandFst is an &quot;FST-like&quot; base-class. ">fst::DeterministicOnDemandFst</a>, and so is their composition. This means that the decoder doesn't have to implement a generic composition algorithm; instead, whenever it crosses an arc in HCLG, it has only to update the language-model state (a state-identifier in F). The decoding algorithm is almost exactly the same as for the baseline, except the state-space (a hash index that we use) is not just the state in HCLG, but a pair of (state in HCLG, state in F). There is no subtantial extra work introduced by this, but this decoder is still a bit slower (e.g. nearly twice as slow in a typical setup) versus a decoder with the same beam, without the "biglm" part. The reason seems to be that with the biglm decoder, more states are in the beam (because a state in HCLG may now have more ``copies'', corresponding to different different histories with distinct langauage model states in HCLG. However, with the same beam, the biglm decoder does give better accuracy than lattice rescoring of lattices produced with a small grammar. The reason, we believe, is better pruning: the ``biglm'' decoder does the Viterbi beam pruning with closer-to-optimal language model scores. Of course, it is still not as good pruning as we would get by using a HCLG compiled with the big grammar, because the biglm decoder only updates the ``good'' language model score every time it crosses a word.</p>
<h1><a class="anchor" id="decoders_lattice"></a>
Lattice generating decoders</h1>
<p>There are lattice-generating versions of some of the decoders described above. There is <a class="el" href="classkaldi_1_1LatticeFasterDecoder.html">LatticeFasterDecoder</a>, <a class="el" href="classkaldi_1_1LatticeSimpleDecoder.html">LatticeSimpleDecoder</a>, and <a class="el" href="classkaldi_1_1LatticeBiglmFasterDecoder.html">LatticeBiglmFasterDecoder</a>. See <a class="el" href="lattices.html">Lattices in Kaldi</a> for more details on lattice generation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Kaldi</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 14:54:46 for Kaldi by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
